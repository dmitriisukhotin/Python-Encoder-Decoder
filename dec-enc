import re
import base64
import struct

def main():
    prompt = userPrompt()
    if prompt == "1":
        encryptedCeasar = notaeCaesarianaeEnc()
        print("Your encrypted text:\n", encryptedCeasar)
    elif prompt == "2":
        encryptedVigenère = chiffre_de_Vigenère_Enc()
        print("Your encrypted text:\n", encryptedVigenère)
    elif prompt == "3":
        encryptedROT13 = rotate_ROT13_Enc()
        print("Your encrypted text:\n", encryptedROT13)
    elif prompt == "4":
        encryptedAtbash = atbash()
        print("Your encrypted text:\n", encryptedAtbash)
    elif prompt == "5":
        encryptedXORASCII, encryptedXORHex = gammyXOR()
        print("Your encrypted text:\nASCII: ", encryptedXORASCII)
        print("\nHex: ", encryptedXORHex)
    elif prompt == "6":
        encryptedROT1 = rot1BroThoughtHeClever()
        print("Your encrypted text:\n", encryptedROT1)
    elif prompt == "7":
        encryptedMorse = morseCode()
        print("Your encrypted text:\n", encryptedMorse)
    elif prompt == "8":
        encryptedBinary = binaryEnc()
        print("Your encrypted text:\n", encryptedBinary)
    elif prompt == "9":
        encryptedBase64 = base64Enc()
        print("Your encrypted text:\n", encryptedBase64)
    elif prompt == "10":
        encryptedMD2 = md2()
        print("Your encrypted text:\n", encryptedMD2)
    elif prompt == "11":
        encryptedMD4 = md4()
        print("Your encrypted text:\n", encryptedMD4.hex())

def userPrompt():
    whatToDo = input("Do you want to Encrypt or Decrypt?(Type enc for Encryption and dec for decryption:)\n")
    if whatToDo == "enc":
        whichOne = input(
            "Which encryption method do you want to use? Type the corresponding number: \n1. Ceasar\n2. Vigenère Cipher\n3. ROT13\n4. Atbash Cipher"
            "\n5. XOR\n6. ROT1\n7. Morse Code\n8. Binary\n9. Base64\n10. MD2\n11. MD4\n12. MD5\n")
        return whichOne
    elif whatToDo == "dec":
        whichOne1 = input("Type a string/key/or text to decrypt:")
        return whichOne1
    else:
        print("Invalid command.")

def notaeCaesarianaeEnc():
    direction = input("In which direction do you want to shift?(f - Forward, b - backward:\n")
    shift = int(input("By how many digits do you want to shift?\n"))
    cesPrompt = input("Type your key/string or text to encrypt:\n")
    encryptedCeasar = ""
    shiftedEC = 0
    for cestxt in cesPrompt:
        myASCII = ord(cestxt)
        if direction == "f":
            shiftedEC = (myASCII + shift)
        elif direction == "b":
            shiftedEC = (myASCII - shift)
        else:
            print("Incorrect direction.\n")
            return
        if shiftedEC < 32:
            shiftedEC += 95
        elif shiftedEC > 126:
            shiftedEC -= 95
        encryptedCeasar += chr(shiftedEC)
    return encryptedCeasar
# def notaeCaesarianaeDec():


def chiffre_de_Vigenère_Enc():
    vigenèreStrE = input("Type your text to encrypt:\n")
    vigenèreKeyE = input("Type your key:\n")
    encVig = ""
    multKey = vigenèreKeyE * (len(vigenèreStrE) // len(vigenèreKeyE)) + vigenèreKeyE[:len(vigenèreStrE) % len(vigenèreKeyE)]
    for i in range(len(vigenèreStrE)):
        if vigenèreStrE[i].isalpha():
            if vigenèreStrE[i].islower():
                vStrE = ord(vigenèreStrE[i]) - ord('a')
                vKeyE = ord(multKey[i]) - ord('a')
                shiftedVigTemp = (vStrE + vKeyE) % 26
                encVig += chr(shiftedVigTemp + ord('a'))
            else:
                vStrE = ord(vigenèreStrE[i]) - ord('A')
                vKeyE = ord(multKey[i]) - ord('A')
                shiftedVigTemp = (vStrE + vKeyE) % 26
                encVig += chr(shiftedVigTemp + ord('A'))
        else:
            encVig += vigenèreStrE[i]
    return encVig

#def chiffre_de_Vigenère_Dec():

def rotate_ROT13_Enc():
    shiftedROT13 = ""
    rot13txt = input("Type your desired text to encrypt:\n")
    for rot13 in rot13txt:
        if rot13 >= 'a' and rot13 <= 'z':
            shiftedROT13 += chr((ord(rot13) - ord('a')) + 13 + ord('a'))
        elif rot13 >= 'A' and rot13 <= 'Z':
            shiftedROT13 += chr((ord(rot13) - ord('A')) + 13 + ord('A'))
        else:
            shiftedROT13 += rot13
    return shiftedROT13

def atbash():
    atbashtxt = input("Type your desired text to encrypt:\n")
    shiftedAtbash = ""
    for atbashh in atbashtxt:
        if 'a' <= atbashh <= 'z':
            shiftedAtbash += chr(ord('z') - (ord(atbashh) - ord('a')))
        elif 'A' <= atbashh <= 'Z':
            shiftedAtbash += chr(ord('Z') - (ord(atbashh) - ord('A')))
        else:
            shiftedAtbash += atbashh
    return shiftedAtbash

def gammyXOR():
    xortxtE = input("Type your text to encrypt:\n")
    xorkeyE = input("Type your key:\n")
    encXOR = ""
    encXORASCII = ""
    multKey = xorkeyE * (len(xortxtE) // len(xorkeyE)) + xorkeyE[:len(xortxtE) % len(xorkeyE)]
    for i, j in zip(xortxtE, multKey):
        encXORASCIItemp = (ord(i) ^ ord(j))
        encXORASCII2 = (encXORASCIItemp % 95) + 32
        encXORASCII += chr(encXORASCII2)
        encXOR += "\\x" + format(encXORASCII2)
    return encXORASCII, encXOR

def rot1BroThoughtHeClever():
    rot1 = input("Type your text to encrypt:\n")
    shiftedROT1 = ""
    for rot1txt in rot1:
        if rot1txt >= 'a' and rot1txt <= 'z':
            shiftedROT1 += chr((ord(rot1txt) - ord('a')) + 1 + ord('a'))
        elif rot1txt >= 'A' and rot1txt <= 'Z':
            shiftedROT1 += chr((ord(rot1txt) - ord('A')) + 1 + ord('A'))
        else:
            shiftedROT1 += rot1txt
    return shiftedROT1

def morseCode():
    morseEnc = input("Type your text to encrypt:\n").upper()
    MORSE_DICT = {'A': '.-', 'B': '-...',
                       'C': '-.-.', 'D': '-..', 'E': '.',
                       'F': '..-.', 'G': '--.', 'H': '....',
                       'I': '..', 'J': '.---', 'K': '-.-',
                       'L': '.-..', 'M': '--', 'N': '-.',
                       'O': '---', 'P': '.--.', 'Q': '--.-',
                       'R': '.-.', 'S': '...', 'T': '-',
                       'U': '..-', 'V': '...-', 'W': '.--',
                       'X': '-..-', 'Y': '-.--', 'Z': '--..',
                       '1': '.----', '2': '..---', '3': '...--',
                       '4': '....-', '5': '.....', '6': '-....',
                       '7': '--...', '8': '---..', '9': '----.',
                       '0': '-----', ', ': '--..--', '.': '.-.-.-',
                       '?': '..--..', '/': '-..-.', '-': '-....-',
                       '(': '-.--.', ')': '-.--.-'}
    encryptedMorse = []
    for char in morseEnc:
        if char in MORSE_DICT:
            encryptedMorse.append(MORSE_DICT[char])
    return ' '.join(encryptedMorse)

def binaryEnc():
    my_binary = input("Type your text to encrypt:\n")
    create_bin = ""
    for b in my_binary:
        create_bin += bin(ord(b))[2:]
    return create_bin

def base64Enc():
    utf8encT = input("Type your text to encrypt:\n")
    utf8enc = utf8encT.encode('utf-8')
    base64EncJ = base64.b64encode(utf8enc)
    return base64EncJ.decode('utf-8')

def md2() -> bytes:
    md21 = input("Type your text to encrypt:\n").encode('utf-8')
    pad_len = 16 - (len(md21) % 16)
    padded_message = md21 + bytes([pad_len] * pad_len)
    state = bytearray(48)
    checksum = bytearray(16)
    for i in range(0,len(padded_message) , 16):
        block = padded_message[i:i + 16]
        for j in range(16):
            checksum[j] ^= state[j]
            checksum[j] = (checksum[j] + block[j]) % 256
        for j in range(16):
            state[j + 16] = state[j]
            state[j] = (state[j] + checksum[j]) % 256
    digest = bytearray(16)
    for i in range(16):
        digest[i] = state[i] ^ state[i + 16]
    return bytes(digest)

def left_rotate(x, n):
    return ((x << n) | (x >> (32 - n))) & 0xFFFFFFFF

def md4() -> bytes:
    md41 = input("Type your text to encrypt:\n").encode('utf-8')
    def F(x, y, z): return (x & y) | (~x & z)
    def G(x, y, z): return (x & y) | (~x & z) | (y & z)
    def H(x, y, z): return x ^ y ^ z

    A = 0x67452301
    B = 0xEFCDAB89
    C = 0x98BADCFE
    D = 0x10325476

    #Padding

    orig_len = len(md41)
    md41 += b'\x80' # Adding 1 bit
    while(len(md41) % 64) != 56:
        md41 += b'\x00' #Adding 0's that can be divide by 512 bit(64 bytes)

    #Adding message length in bits(64 bit number, fisrt byte is smallest)
    md41 += struct.pack('<Q', orig_len * 8)

    #Dividing message in blocks by 512 bits

    for i in range(0, len(md41), 64):
        block = md41[i:i+64]
        X = struct.unpack('<16I', block) #Dividing block by 16 32words' bit

        #Saving current state
        AA, BB, CC, DD = A, B, C, D

        #First round
        A = left_rotate((A + F(B, C, D) + X[0]), 3)
        D = left_rotate((D + F(B, C, D) + X[1]), 7)
        C = left_rotate((C + F(B, C, D) + X[2]), 11)
        B = left_rotate((B + F(B, C, D) + X[3]), 19)

        A = left_rotate((A + F(B, C, D) + X[4]), 3)
        D = left_rotate((D + F(A, B, C) + X[5]), 7)
        C = left_rotate((C + F(D, A, B) + X[6]), 11)
        B = left_rotate((B + F(C, D, A) + X[7]), 19)

        A = left_rotate((A + F(B, C, D) + X[8]), 3)
        D = left_rotate((D + F(A, B, C) + X[9]), 7)
        C = left_rotate((C + F(D, A, B) + X[10]), 11)
        B = left_rotate((B + F(C, D, A) + X[11]), 19)

        A = left_rotate((A + F(B, C, D) + X[12]), 3)
        D = left_rotate((D + F(A, B, C) + X[13]), 7)
        C = left_rotate((C + F(D, A, B) + X[14]), 11)
        B = left_rotate((B + F(C, D, A) + X[15]), 19)

        #Second round
        A = left_rotate((A + G(B, C, D) + X[0] + 0x5A827999), 3)
        D = left_rotate((D + G(A, B, C) + X[4] + 0x5A827999), 5)
        C = left_rotate((C + G(D, A, B) + X[8] + 0x5A827999), 9)
        B = left_rotate((B + G(C, D, A) + X[12] + 0x5A827999), 13)

        A = left_rotate((A + G(B, C, D) + X[1] + 0x5A827999), 3)
        D = left_rotate((D + G(A, B, C) + X[5] + 0x5A827999), 5)
        C = left_rotate((C + G(D, A, B) + X[9] + 0x5A827999), 9)
        B = left_rotate((B + G(C, D, A) + X[13] + 0x5A827999), 13)

        A = left_rotate((A + G(B, C, D) + X[2] + 0x5A827999), 3)
        D = left_rotate((D + G(A, B, C) + X[6] + 0x5A827999), 5)
        C = left_rotate((C + G(D, A, B) + X[10] + 0x5A827999), 9)
        B = left_rotate((B + G(C, D, A) + X[14] + 0x5A827999), 13)

        A = left_rotate((A + G(B, C, D) + X[3] + 0x5A827999), 3)
        D = left_rotate((D + G(A, B, C) + X[7] + 0x5A827999), 5)
        C = left_rotate((C + G(D, A, B) + X[11] + 0x5A827999), 9)
        B = left_rotate((B + G(C, D, A) + X[15] + 0x5A827999), 13)

        #Third round
        A = left_rotate((A + H(B, C, D) + X[0] + 0x6ED9EBA1), 3)
        D = left_rotate((D + H(A, B, C) + X[8] + 0x6ED9EBA1), 9)
        C = left_rotate((C + H(D, A, B) + X[4] + 0x6ED9EBA1), 11)
        B = left_rotate((B + H(C, D, A) + X[12] + 0x6ED9EBA1), 15)

        A = left_rotate((A + H(B, C, D) + X[2] + 0x6ED9EBA1), 3)
        D = left_rotate((D + H(A, B, C) + X[10] + 0x6ED9EBA1), 9)
        C = left_rotate((C + H(D, A, B) + X[6] + 0x6ED9EBA1), 11)
        B = left_rotate((B + H(C, D, A) + X[14] + 0x6ED9EBA1), 15)

        A = left_rotate((A + H(B, C, D) + X[1] + 0x6ED9EBA1), 3)
        D = left_rotate((D + H(A, B, C) + X[9] + 0x6ED9EBA1), 9)
        C = left_rotate((C + H(D, A, B) + X[5] + 0x6ED9EBA1), 11)
        B = left_rotate((B + H(C, D, A) + X[13] + 0x6ED9EBA1), 15)

        A = left_rotate((A + H(B, C, D) + X[3] + 0x6ED9EBA1), 3)
        D = left_rotate((D + H(A, B, C) + X[11] + 0x6ED9EBA1), 9)
        C = left_rotate((C + H(D, A, B) + X[7] + 0x6ED9EBA1), 11)
        B = left_rotate((B + H(C, D, A) + X[15] + 0x6ED9EBA1), 15)

        #Adding value to the initial state
        A = (A + AA) & 0xFFFFFFFF
        B = (B + BB) & 0xFFFFFFFF
        C = (C + CC) & 0xFFFFFFFF
        D = (D + DD) & 0xFFFFFFFF

    #Returning result hash in 16 byte (128 bit) state

    return struct.pack('<4I', A, B, C, D)

if __name__ == "__main__":
    main()

